# task-draft

```c++
auto life = While([I = *this] { return I.alive(); })(
    [] { TRY(); },
    If[ ([] { return SUCCESS(); }) ](
        [] { std::cout << "Happy Party!" << std::endl; }
    )->Else(
        [] { REVIEW(); }
    )
);
```

## これは何？

DSLを用いて簡単にタスクを設定し、制御周期毎の呼び出しに対応した処理をしてくれるもの。

現在は作成中。これを見た人には様々な指摘をして欲しい。特に欲しがっている指摘は下の「[課題](#課題)」を参照。

## DSLの記法

何と言っても、DSLは分かりやすいほど良い。今回は次のルールに従った文法を実現できた。

-   関数オブジェクトと各コマンドを同様に扱える
-   各コマンドは大文字始まりのキャメルケース
-   条件式は`operator[]`か`operator()`を通して、`std::function<bool()>`で指定
-   タスクを複数まとめて渡すブロックは`()`で囲む
-   タスク要素に属性を追加する時は`->`に属性名を続ける
-   関数タスクの引数は`{}`または`()`
-   タスク間の区切りは`,`

この説明では分かりにくいので、下に実装結果を書く。

### 関数オブジェクト

引数無しで呼べ、返り値が`void`か`bool`の関数オブジェクトを渡すと、`Task`クラスのオブジェクトとして一連のタスク処理の中に組み込まれる。
次の例は、渡したラムダ式を順に実行する(`TaskSet`については後述)。

```c++
auto&& task = TaskSet(
    [] { /* 処理1 */ },
    [] { /* 処理2 */ },
    [] { /* 処理3 */ }
);
```

タスク処理中、各々の要素について「この処理はもう終了していて、直ぐに次の処理に移っていい」と「この処理はまだ終了せず、次のサイクルにもう一度実行する」の2通りの結果を扱っている。
関数オブジェクトも同様で、返り値の型が`bool`の時、それが`true`なら処理終了と、`false`なら処理未完了(次サイクルで継続)と読み取られる。`void`は常に`true`を返すものとして扱われる。

例えば次のタスクは永遠に終わらない。

```c++
auto&& tmp = TaskSet(
    [] { /* 永遠に呼ばれる処理 */; return false; },
    [] { /* 永遠に呼ばれない処理 */ }
);
```

上手く使えば、複雑な処理を1つのラムダ式に登録できる。

#### 注意

このライブラリでは、コピーできない関数オブジェクトや、コピーで例外の発生する関数オブジェクトを考慮していない。

### `If`, `ElseIf`, `Else`

見ての通り。

```c++
If[条件式](
    タスク(任意数)...

)->ElseIf[条件式](
    タスク(任意数)...

)->ElseIf[条件式](
    ElseIfも任意数...

)->Else(
    タスク...
)
```

先述の通り、条件式を囲む括弧は`()`も可能。これは`[]`の中に直接ラムダ式を入れると`[[attribute]]`と混同してコンパイルが通らない為の措置である。

Elseの後には、当然`ElseIf`も`Else`も続けられない。

### ループ(`While`, `Until`, `Do~While`, `Until`)

```c++
While[条件式](

)
```

```c++
Until[条件式](

)
```

```c++
Do(

)->While[]
```

```c++
Do(

)->Until[]
```

### 待機(`Wait`)

条件式がtrueを返すまで待つ。

```c++
Wait[条件式]
```

### 一定カウント停止(`Delay`)

`count`の回数呼び出されると次の処理に移行するようになる。

```c++
Delay{count}
```

### ループクラス実行(`RunLoop`)

```c++
RunLoop<LoopType>(args...)
```

`LoopType`に使えるのは、メンバ関数`start()`、`stop()`、`running()`を持つクラス。`start()`を呼び出されると別スレッドで処理を開始し、終了するまで`running()`が`true`を返すクラスを想定している。そのコンストラクタに渡す引数を`args...`に入れる。

### タスクブロック作成(`TaskSet`)

上記の`If`や`While`に渡すときには特に意識する必要はないが、タスクのブロックを生成するコマンドが有る。

```c++
TaskSet(
    [] { /* タスク1 */ },
    If[条件式](
        ...
    ),
    :
    :

)
```

主に、DSL全体を包んで1つの変数に入れるときなどに使う。

### 変数保存可能

```c++
auto&& tmp_do = Do(
    タスク...
);

auto&& task = TaskSet(
    tmp_do->While[条件式],
    tmp_do->Until[条件式]
)
```

上記のように、DSLの途中までを変数に格納し、その続きを後で加えることが出来る。
その場合は基本的に、内部でタスクがコピーされるため、衝突などは起こらない。

しかし、`If`文については、次のような使用法を想定し、内部コピーはなされない。

```c++
auto&& tmp_if = If[条件式](
    タスク...
);

// 条件式追加
tmp_if->ElseIf[条件式](
    タスク...
);

// 条件式追加2
tmp_if->ElseIf[条件式](
    タスク...
);

auto&& task = TaskSet(
    tmp_if,
    :
    :

);
```

コピーして別の条件分岐を作りたい場合は`copy`メソッドを呼ぶ。

```c++
//(上の式の続き)

auto&& task2 = TaskSet(
    tmp_if->copy()->Else(
        Else節1...

    ),
    tmp_if->copy()->Else(
        Else節2...

    ),
    :
    :

);
```

ちなみに、`If`文の格納した変数に`->Else()`を実行した後も、`->EleseIf[]()`や`->Else()`を実行できる。
勿論それらの条件が呼ばれることは無い(`Else`を必ず実行される`ElseIf`と見なす)。

```c++
auto&& tmp_if = If[条件式](
    タスク...
);

tmp_if->Else(

);

// エラーにならない
tmp_if->ElseIf[条件式](

);


// Else呼んだ結果を格納すると
auto&& tmp_if2 = tmp_if->Else(

);

// これはコンパイルエラーになる
// tmp_if2->Else();
```

## 何が強い？

折角作ったので、全力で推す。

### 安全性

DSLとは「中でどうなっているか知らんけどきちんと動く」という**カプセル化の最終到達点**。DSL表記の為とは言え安全性を損なってはならない。

#### メモリリークなし

様々なタスククラスのオブジェクトを統一的に扱ったり、DSLの表記に`->`が多く使われていたり、途中で変数に保存しても問題ないようにデータ寿命を延ばしたりと、ポインタを多用していることは明らかだが、利用者がどんな使い方をしようとメモリリークは起こさないようにした。

#### コピー・ムーブの管理

上記の通り、内部ではポインタを用いらざるを得ない。ゆえに、単にコピーするだけではメンバとして管理しているタスクがコピーされず、期待通りの挙動を示さない。

今回の実装では、どのタスクを変数に入れてもコピーしてもよく、コンパイルが通る限り実行時エラーも出ないプログラムを実現した。(コピー・ムーブなどが出来ない場合は対応する関数を`= delete`指定し、時には代替案(`copy`メソッドなど)を用意した。)

#### `nullptr`を登録できる

ポインタを扱う以上、避けては通れないnullptrの管理を徹底した。あなたはもう、ライブラリ内のセグフォに悩まされない。

また、使用する機会が少ないので忘れがちだが、`std::function`も`nullptr`を持ちうる。その状態で`operator()`を呼び出すと例外を送出するが、こちらも注意を払った。

### タスク処理部での実行時エラーをゼロへ

無効なリソースを使用しない、実行時にエラーになるならばコンパイルでエラー検出をする、などの対策を取り、タスク処理機構内部でのエラー送出を無くすよう努めた。

登録する関数オブジェクト内でエラーが送出される状況などは当然防げないが、そうでないエラーは撲滅できるはずである。

### 不要な処理を排除し、計算リソースを圧迫しない

適切な関数で`noexcept`を指定したり、データのコピー・ムーブの回数を極限まで減らしたりと、可能な限り処理を軽くした。その過程でソースコードの可読性は若干落ちたが、タスクの遂行を助けるはずのシステムがタスクの邪魔になってならない、という前提は守れたかと思う。

### 拡張を容易に

全てのタスククラスの基底に位置する`AbstTask`クラスには4つの仮想関数があり、子クラスではそれらを定義すれば十全に動く。実際、DSLとしての機能を定義する部分は複雑であるものの、格納された後のタスク処理は非常にシンプルなコードになっている。

`AbstTask`クラスの持つ仮想関数は次の通り

*   `void init()`: タスクの遂行が始まる直前に呼ばれる
*   `bool eval()`: タスクの遂行を行う部分。返り値は関数オブジェクトの項と同様
*   `void quit()`: タスク終了直後に呼ばれる
*   `void interrupt()`: タスクの実行中に中断された時に呼ばれる。デフォルトでは`quit()`を呼び出す。

これに加えて、`AbstTask`には`std::function<void()>`型の`public`メンバ変数`interrupt_func`があり、これを設定すると`interrupt()`の直後に呼び出されるようになる。

## 課題

もちろん現段階の実装は完璧ではないので、色々指摘してほしい。

むしろ、ひたすら攻撃的な使用法を試して穴を見つけてください。
あ、でも、テンプレートのハチャメチャな特殊化とかは勘弁してください。

### 読めば使えるドキュメント

現在のドキュメントは、コード中に多少散りばめられたコメントと、これだけである。
DSLの記法がイマイチ分からずに、結局実装の中身を読むはめになるのはDSLの意味がないので、ここはしっかりしなきゃならぬ。`TaskSet`等でメタ関数を多用しているなどもあって、コードの可読性も高くないので尚更である。

「この辺わかりにくい」などの情報が有ると、ドキュメント作成時に大きな助けになる。

### 並列処理を考える

実装者が未だ並列処理に慣れていないので、どこを気を付けるべきか分からない。
その為、何の対策もされていない。

「この辺はatomicで」などの情報がとても欲しい。

### 他ライブラリ対応

これ単体で動くコードを作っているので、全てのライブラリ環境に対応しているわけではない。
例えば、問答無用で`std::cout`を使用していたり、名前空間を用いた隠蔽が不十分だったり。

### 真の安全性を目指せ

無効な関数オブジェクトを呼ばないように、など気を付けているが、まだ穴が有るかもしれない。
処理を速める為に積極的に`noexcept`を指定しているが、もしかしたら不適切な指定もされているかもしれない。

突然の`std::terminate()`は悲しいので、真の安全性に向けて殴り込みを仕掛けて欲しい。
